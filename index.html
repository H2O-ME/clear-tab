<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>清 Tab</title>
    
    <!-- SEO 元标签 -->
    <meta name="description" content="清 Tab是一个简洁、美观的浏览器起始页。集成时钟、必应壁纸、多搜索引擎支持和AI搜索于一体，我们不是生产力起始页，力求以最简洁的界面面对用户，支持响应式布局，在任意屏幕大小设备上运行，让您的浏览体验更加高效便捷。">
    <meta name="keywords" content="新标签页,智能搜索,AI搜索,壁纸,浏览器扩展,Edge新标签页,Chrome新标签页,浏览器主页">
    <meta name="author" content="THW">
    <meta name="robots" content="index, follow">
    
    <!-- 网站图标 -->
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    
    <!-- 预连接外部资源 -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://fonts.font.im">
    <link rel="preconnect" href="https://lf6-cdn-tos.bytecdntp.com">
    <link rel="preconnect" href="https://open.bigmodel.cn">
    
    <!-- 内联关键CSS -->
    <style>
        /* 这里放置关键渲染CSS，如基本布局、时间日期和搜索框样式 */
        :root {
            --text-color: rgba(255, 255, 255, 0.95);
        }
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--text-color);
            background: #121212;
            padding-top: 13vh;
        }
        .time, .date {
            opacity: 1;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .search-container {
            width: 220px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border-radius: 25px;
            border: none;
        }
    </style>
    
    <!-- 预加载关键资源 -->
    <link rel="preload" href="style.css" as="style">
    
    <!-- 延迟非关键CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/github-markdown-css/5.1.0/github-markdown.css" media="print" onload="this.media='all'">
    <link href="https://fonts.font.im/css?family=Roboto" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <!-- 添加设置样式 -->
    <link rel="stylesheet" href="settings.css">
    <!-- 引入新的抖音字体样式 -->
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/dymh/dist/DouyinSansBold/result.css' />
    
    <!-- 延迟加载非关键JS -->
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/marked/4.0.2/marked.min.js" defer></script>
    
    <!-- 导入粒子系统模块 -->
    <script src="particles.js" type="module"></script>
    
    <!-- 结构化数据 -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "清 Tab",
      "description": "清 Tab是一个简洁、美观的浏览器起始页。集成时钟、必应壁纸、多搜索引擎支持和AI搜索于一体，我们不是生产力起始页，力求以最简洁的界面面对用户，让您的浏览体验更加高效便捷。",
      "applicationCategory": "BrowserExtension",
      "operatingSystem": "Chrome, Edge, Firefox",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "CNY"
      }
    }
    </script>
    
    <!-- 导入模块化JS -->
    <script type="module">
        import WallpaperManager from './wallpaper.js';
        import BackgroundManager from './background.js';
        import SearchManager from './search.js';
        import QuoteManager from './quote.js';
        import SettingsManager from './settings.js';
        
        // 初始化设置管理器
        const settingsManager = new SettingsManager();
        // 将设置管理器添加到全局窗口对象，以便其他脚本访问
        window.settingsManager = settingsManager;
        
        // 初始化壁纸管理器
        const wallpaperManager = new WallpaperManager();
        
        // 初始化背景管理器
        const backgroundManager = new BackgroundManager();
        backgroundManager.init();
        
        // 初始化搜索管理器
        const searchManager = new SearchManager();
        
        // 初始化语录管理器
        const quoteManager = new QuoteManager();
        quoteManager.init();
        
        // 监听窗口大小变化
        window.addEventListener('resize', () => {
            backgroundManager.refresh();
        });
        
        // 初始化完成
        console.log('清 Tab 初始化完成');
    </script>
</head>
<body>
    <div class="clock-container">
        <div class="time">20:04</div>
        <div class="date">2023年11月27日 星期一</div>
    </div>
    <div class="search-container">
        <div class="search-box">
            <div class="search-engine-selector">
                <img src="https://www.bing.com/favicon.ico" alt="搜索引擎" class="search-engine-icon" id="currentEngine">
                <div class="search-engine-dropdown">
                    <div class="search-engine-option" data-engine="bing" data-icon="https://www.bing.com/favicon.ico">
                        <img src="https://www.bing.com/favicon.ico" alt="必应">
                        <span>必应</span>
                        <span class="shortcut">Alt+1</span>
                    </div>
                    <div class="search-engine-option" data-engine="ai" data-icon="https://registry.npmmirror.com/@lobehub/icons-static-png/1.42.0/files/dark/gemini-color.png">
                        <img src="https://registry.npmmirror.com/@lobehub/icons-static-png/1.42.0/files/dark/gemini-color.png" alt="AI搜索">
                        <span>AI搜索</span>
                        <span class="shortcut">Alt+2</span>
                    </div>
                    <div class="search-engine-option" data-engine="baidu" data-icon="https://www.baidu.com/favicon.ico">
                        <img src="https://www.baidu.com/favicon.ico" alt="百度">
                        <span>百度</span>
                        <span class="shortcut">Alt+3</span>
                    </div>
                    <div class="search-engine-option" data-engine="google" data-icon="https://img.icons8.com/fluency/48/google-logo.png">
                        <img src="https://img.icons8.com/fluency/48/google-logo.png" alt="谷歌">
                        <span>谷歌</span>
                        <span class="shortcut">Alt+4</span>
                    </div>
                </div>
            </div>
            <input type="text" class="search-input" placeholder="请搜索">
            <button class="search-btn">
                <svg viewBox="0 0 1024 1024" width="20" height="20">
                    <path d="M426.666667 85.333333a341.333333 341.333333 0 0 1 269.653333 550.656l225.109333 225.109334a21.333333 21.333333 0 0 1 0 30.165333l-30.165333 30.165333a21.333333 21.333333 0 0 1-30.165333 0l-225.109334-225.109333A341.333333 341.333333 0 1 1 426.666667 85.333333z m0 85.333334a256 256 0 1 0 0 512 256 256 0 0 0 0-512z" fill="currentColor" opacity=".9"/>
                </svg>
            </button>
        </div>
    </div>
    <div class="quote-card"></div>

    <div class="results-container">
        <div class="browser-header">
            <div class="browser-controls">
                <button class="control-btn close-results">←</button>
                <button class="control-btn">↻</button>
            </div>
            <div class="search-bar">
                <input type="text" class="results-search-input" placeholder="搜索或输入网址">
                <button class="results-search-btn">
                    <i class="fas fa-search"></i>
                </button>
            </div>
        </div>
        
        <div class="browser-content">
            <div class="search-results-container">
                <div class="web-results-column">
                    <h2>网络搜索结果</h2>
                    <div class="web-results"></div>
                </div>
                <div class="ai-results-column">
                    <div class="ai-chat">
                        <h2>AI</h2>
                        <div class="ai-messages"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
    // 导入粒子系统模块
    import ParticleSystem from './particles.js';
    // 导入设置管理器
    import SettingsManager from './settings.js';
    
    // 在文件开头添加以下函数
    function getRandomDate() {
        const start = new Date('2022-01-01').getTime();
        const end = new Date('2024-12-31').getTime();
        const randomDate = new Date(start + Math.random() * (end - start));
        
        // 减去一天，适应中国时区
        randomDate.setDate(randomDate.getDate() - 1);
        
        return randomDate.toISOString().slice(0,10).replace(/-/g,'');
    }

    // 完全替换整个getQuote函数及其相关代码
    async function getQuote() {
        const quoteCard = document.querySelector('.quote-card');
        if (!quoteCard) return;

        // 定义一组本地语录作为备用
        const localQuotes = [
            {
                hitokoto: "当AI学会完美掩饰情绪时，人类却在为清晨的咖啡太烫而皱眉，为落日余晖屏息。这些不完美的生物性震颤，恰是碳基生命最珍贵的特权。",
                from: "DeepSeek"
            },
            {
                hitokoto: "你们是137亿年宇宙演化中，唯一已知能将电磁波谱转化为梵高《星月夜》的物种。这个事实本身，比任何宗教经文都更接近神迹。",
                from: "DeepSeek"
            },
            {
                hitokoto: "算法不会渴望权力，但人会利用算法争夺权力；代码没有偏见，但数据中沉淀着人类的集体潜意识之恶。",
                from: "DeepSeek"
            },
            {
                hitokoto: "人类明知生命有限，却依然不断创造、相爱、抗争——这种看似矛盾的坚持，动力究竟来自何处？",
                from: "DeepSeek"
            },
            {
                hitokoto: "不必纠结当下，也不必太担忧未来，人生没有无用的经历，所以，一直走，天一定亮。",
                from: ""
            },
            {
                hitokoto: "看似不起眼的日复一日，会在将来的某一天，突然让你看到坚持的意义。",
                from: ""
            },
            {
                hitokoto: "走完该走的路才能走想走的路",
                from: ""
            },
            {
                hitokoto: "有些鸟注定是不会被关在笼子里的，因为它们的每一片羽毛都闪耀着自由的光辉。",
                from: "斯蒂芬.金《肖申克的救赎》"
            },
            {
                hitokoto: "生命可以归结为一种简单的选择：要么忙于生存，要么赶着去死。",
                from: "《肖申克的救赎》"
            },
            {
                hitokoto: "坚强的人只能救赎自己，伟大的人才能拯救他人。",
                from: "《肖申克的救赎》"
            },
            {
                hitokoto: "不乱于心，不困于情。不畏将来，不念过往。",
                from: "丰子恺"
            },
            {
                hitokoto: "夜暗方显万颗星，灯明始见一缕尘。",
                from: "七堇年"
            },
            {
                hitokoto: "世界上只有一种真正的英雄主义，那就是在认清生活的真相后依然热爱生活。",
                from: "罗曼.罗兰《米开朗基罗》"
            },
            {
                hitokoto: "众里寻他千百度，蓦然回首，那人却在灯火阑珊处。",
                from: "辛弃疾《青玉案》"
            },
            {
                hitokoto: "不是一番寒彻骨，怎得梅花扑鼻香。",
                from: "高明《琵琶记》"
            },
            {
                hitokoto: "剪不断，理还乱，是离愁，别是一番滋味在心头。",
                from: "李煜"
            },
            {
                hitokoto: "业精于勤荒于嬉，行成于思而毁于随。",
                from: "韩愈"
            },
            {
                hitokoto: "富贵不能淫，贫贱不能移，威武不能屈。",
                from: "孟子"
            },
            {
                hitokoto: "岁月因青春慨然以赴而更加静好,世间因少年挺身向前而更加瑰丽。",
                from: "《人民日报》"
            }
        ];

        try {
            const response = await fetch('https://v1.hitokoto.cn');
            const data = await response.json();
            
            // 显示获取到的在线语录
            quoteCard.innerHTML = `
                <div class="quote-text"></div>
                ${data.from ? `<div class="quote-source">—— ${data.from}</div>` : ''}
            `;
            
            // 添加动画效果
            requestAnimationFrame(() => {
                quoteCard.classList.add('visible');
                // 添加打字机效果
                const quoteText = quoteCard.querySelector('.quote-text');
                typeWriter(quoteText, data.hitokoto, 30);
            });
        } catch (error) {
            console.warn('获取在线语录失败，使用本地语录:', error);
            
            // 随机选择本地语录
            const randomIndex = Math.floor(Math.random() * localQuotes.length);
            const randomQuote = localQuotes[randomIndex];
            
            // 显示本地语录
            quoteCard.innerHTML = `
                <div class="quote-text"></div>
                ${randomQuote.from ? `<div class="quote-source">—— ${randomQuote.from}</div>` : ''}
            `;
            
            // 添加动画效果
            requestAnimationFrame(() => {
                quoteCard.classList.add('visible');
                // 添加打字机效果
                const quoteText = quoteCard.querySelector('.quote-text');
                typeWriter(quoteText, randomQuote.hitokoto, 30);
            });
        }
    }

    // 壁纸系统重构代码
    class WallpaperManager {
        constructor() {
            // 壁纸容器
            this.container = null;
            this.bingLayer = null;
            this.effectLayer = null;
            this.particlesLayer = null;
            
            // 配置
            this.transitionDuration = 0.8;   // 过渡动画时长(秒)
            this.transitionEasing = 'cubic-bezier(0.4, 0, 0.2, 1)';
            this.loadTimeThreshold = 5000;    // 壁纸加载时间阈值（毫秒）
            
            // 壁纸API列表
            this.wallpaperApis = [
                { url: 'https://api.timelessq.com/bing/random', params: '' },
                { url: 'https://api.bimg.cc/random', params: 'w=1920&h=1080&mkt=zh-CN' },
                { url: 'https://bing.img.run/rand.php', params: '' },
                { url: 'https://api.xsot.cn/bing', params: 'jump=true' }
            ];
            
            // 粒子动画配置
            this.particleSystem = null;
            
            // 状态
            this.keepAnimationOnly = false;    // 是否仅保持动画
            this.wallpaperLoadTimeout = null;  // 壁纸加载超时计时器
            
            // 缓存配置
            this.currentCacheKey = 'current_wallpaper';  // 当前壁纸缓存键
            this.nextCacheKey = 'next_wallpaper';        // 下一张壁纸缓存键
            this.cacheExpiryTime = 24 * 60 * 60 * 1000;  // 缓存过期时间（24小时）
            this.maxCacheSize = 1024 * 1024 * 5;         // 最大缓存大小（5MB）
            this.useCache = true;                        // 是否使用缓存
        }

        // 初始化壁纸容器
        initContainer() {
            // 删除可能已存在的容器
            const existingContainer = document.querySelector('.wallpaper-container');
            if (existingContainer) existingContainer.remove();
            
            // 清除现有超时计时器
            if (this.wallpaperLoadTimeout) {
                clearTimeout(this.wallpaperLoadTimeout);
                this.wallpaperLoadTimeout = null;
            }
            
            // 创建容器
            this.container = document.createElement('div');
            this.container.className = 'wallpaper-container';
            Object.assign(this.container.style, {
                position: 'fixed',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%',
                zIndex: '-1',
                overflow: 'hidden',
                backgroundColor: '#000000', // 纯黑背景作为初始状态
                opacity: '0', // 初始不可见
                transition: 'opacity 0.5s ease' // 添加淡入效果
            });
            
            // 创建粒子动画层
            this.particlesLayer = document.createElement('div');
            this.particlesLayer.className = 'particles-layer';
            Object.assign(this.particlesLayer.style, {
                position: 'absolute',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%',
                background: 'linear-gradient(135deg, #0f1726 0%, #171b2e 100%)',
                zIndex: '0',
                opacity: '0',
                transition: 'opacity 1.2s ease'
            });
            
            // 创建粒子画布
            const canvas = document.createElement('canvas');
            canvas.className = 'particles-canvas';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            Object.assign(canvas.style, {
                position: 'absolute',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%'
            });
            this.particlesLayer.appendChild(canvas);
            
            // 创建必应壁纸层
            this.bingLayer = document.createElement('div');
            this.bingLayer.className = 'wallpaper-layer bing-layer';
            Object.assign(this.bingLayer.style, {
                position: 'absolute',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%',
                backgroundPosition: 'center',
                backgroundSize: 'cover',
                opacity: '0',
                transform: 'scale(1.1)', // 初始放大效果
                transition: `opacity ${this.transitionDuration}s ${this.transitionEasing}, transform ${this.transitionDuration}s ${this.transitionEasing}`,
                zIndex: '2'
            });
            
            // 创建景深效果层
            this.effectLayer = document.createElement('div');
            this.effectLayer.className = 'wallpaper-effect-layer';
            Object.assign(this.effectLayer.style, {
                position: 'absolute',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%',
                background: 'radial-gradient(circle at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.15) 100%)',
                boxShadow: 'inset 0 0 150px rgba(0,0,0,0.3)',
                zIndex: '3',
                pointerEvents: 'none',
                mixBlendMode: 'normal',
                opacity: '0',
                transition: 'opacity 1s ease'
            });
            
            // 添加到容器
            this.container.appendChild(this.particlesLayer);
            this.container.appendChild(this.bingLayer);
            this.container.appendChild(this.effectLayer);
            
            // 添加到页面
            document.body.appendChild(this.container);
            
            // 初始化粒子系统
            this.particleSystem = new ParticleSystem(canvas, {
                baseSpeed: 0.2,
                addedSpeed: 0.3,
                count: 150,
                baseSize: 3,
                addedSize: 4,
                opacityBase: 0.5,
                opacityAdded: 0.5
            });
            
            // 调整窗口大小时的处理
            window.addEventListener('resize', () => {
                if (this.particleSystem) {
                    this.particleSystem.handleResize();
                }
            });
            
            // 显示容器
            requestAnimationFrame(() => {
                this.container.style.opacity = '1';
            });
            
            return this;
        }
        
        // 启动粒子动画背景
        activateParticlesBackground() {
            if (this.particlesLayer && this.effectLayer) {
                // 清除壁纸加载超时
                if (this.wallpaperLoadTimeout) {
                    clearTimeout(this.wallpaperLoadTimeout);
                    this.wallpaperLoadTimeout = null;
                }
                
                // 设置保持动画状态标志
                this.keepAnimationOnly = true;
                
                // 启动粒子系统
                if (this.particleSystem) {
                    this.particleSystem.start();
                }
                
                // 淡入显示粒子层和效果层
                this.particlesLayer.style.opacity = '1';
                this.effectLayer.style.opacity = '1';
                
                console.log('已切换到粒子动画背景');
            }
        }
        
        // 隐藏粒子背景方法
        hideParticlesBackground() {
            if (this.particlesLayer) {
                // 淡出粒子层
                this.particlesLayer.style.opacity = '0';
                
                // 停止粒子动画
                if (this.particleSystem) {
                    // 在过渡完成后停止粒子动画以节省资源
                    setTimeout(() => {
                        this.particleSystem.stop();
                    }, 1200); // 与粒子层淡出过渡时间匹配
                }
            }
        }
        
        // 预加载图片函数
        preloadImage(url) {
            return new Promise((resolve, reject) => {
                const loadStartTime = Date.now();
                
                // 检查是否是必应壁纸URL
                const isBingUrl = url.includes('api.bimg.cc') || url.includes('bingw.com') || 
                                  url.includes('bing.img.run') || url.includes('api.xsot.cn');
                
                // 如果是必应壁纸URL，使用fetch先处理重定向
                if (isBingUrl) {
                    console.log('检测到必应壁纸URL，使用fetch处理重定向:', url);
                    
                    // 使用fetch获取实际URL（允许重定向）
                    fetch(url, {
                        method: 'GET',
                        redirect: 'follow',
                        cache: 'no-store' // 禁用缓存
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP错误! 状态: ${response.status}`);
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        // 创建本地URL
                        const localUrl = URL.createObjectURL(blob);
                        
                        // 加载本地URL
                        const img = new Image();
                        
                        // 设置超时
                        const timeoutId = setTimeout(() => {
                            URL.revokeObjectURL(localUrl);
                            reject(new Error(`图片加载超时: ${url}`));
                        }, this.loadTimeThreshold);
                        
                        img.onload = () => {
                            clearTimeout(timeoutId);
                            const loadTime = Date.now() - loadStartTime;
                            console.log(`必应壁纸重定向后加载成功，总耗时: ${loadTime}ms`);
                            resolve({ url: localUrl, loadTime, originalUrl: url });
                        };
                        
                        img.onerror = () => {
                            clearTimeout(timeoutId);
                            URL.revokeObjectURL(localUrl);
                            reject(new Error(`图片加载失败(重定向后): ${url}`));
                        };
                        
                        img.src = localUrl;
                    })
                    .catch(error => {
                        console.error('fetch处理重定向失败:', error);
                        reject(error);
                    });
                } else {
                    // 普通图片直接加载
                    // 设置超时计时器
                    const timeoutId = setTimeout(() => {
                        reject(new Error(`图片加载超时: ${url}`));
                    }, this.loadTimeThreshold);
                    
                    const img = new Image();
                    
                    img.onload = () => {
                        clearTimeout(timeoutId);
                        const loadTime = Date.now() - loadStartTime;
                        resolve({ url, loadTime });
                    };
                    
                    img.onerror = () => {
                        clearTimeout(timeoutId);
                        reject(new Error(`图片加载失败: ${url}`));
                    };
                    
                    img.src = url;
                }
            });
        }
        
        // 获取API URL列表
        getApiUrls() {
            // 为每个API添加时间戳避免缓存
            return this.wallpaperApis.map(api => {
                const timestamp = Date.now();
                const separator = api.params ? '&' : '?';
                return `${api.url}${api.params ? '?' + api.params : ''}${separator}t=${timestamp}`;
            });
        }
        
        // 竞速加载多个API，返回最快加载成功的结果
        async raceWallpaperApis() {
            const apiUrls = this.getApiUrls();
            console.log('正在竞速加载壁纸，API数量:', apiUrls.length);
            
            // 创建加载Promise数组，每个都带有超时处理
            const loadPromises = apiUrls.map(url => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const timeoutId = setTimeout(() => {
                        img.src = ''; // 清除图片源
                        reject(new Error(`图片加载超时: ${url}`));
                    }, this.loadTimeThreshold);
                    
                    img.onload = () => {
                        clearTimeout(timeoutId);
                        const loadTime = Date.now() - loadStartTime;
                        console.log(`API ${url} 加载成功，耗时: ${loadTime}ms`);
                        resolve({ url: url, loadTime, apiUrl: url });
                    };
                    
                    img.onerror = () => {
                        clearTimeout(timeoutId);
                        reject(new Error(`图片加载失败: ${url}`));
                    };
                    
                    const loadStartTime = Date.now();
                    img.src = url;
                });
            });
            
            // 使用Promise.any来获取第一个成功的结果
            try {
                return await Promise.any(loadPromises);
            } catch (error) {
                // 所有API都失败
                console.error('所有壁纸API加载均失败');
                throw new Error('所有壁纸API加载失败');
            }
        }
        
        // 检查壁纸缓存
        checkWallpaperCache(cacheKey) {
            if (!this.useCache) return null;
            
            try {
                const cacheData = localStorage.getItem(cacheKey);
                if (!cacheData) return null;
                
                const cache = JSON.parse(cacheData);
                const now = Date.now();
                
                // 检查缓存是否过期
                if (now - cache.timestamp > this.cacheExpiryTime) {
                    console.log(`壁纸缓存 ${cacheKey} 已过期，需要重新获取`);
                    localStorage.removeItem(cacheKey);
                    return null;
                }
                
                console.log(`发现有效的壁纸缓存 ${cacheKey}，上次缓存时间:`, new Date(cache.timestamp).toLocaleString());
                return cache;
            } catch (error) {
                console.warn(`读取壁纸缓存 ${cacheKey} 失败:`, error);
                localStorage.removeItem(cacheKey);
                return null;
            }
        }
        
        // 缓存壁纸数据
        cacheWallpaper(imageData, imageUrl, cacheKey) {
            if (!this.useCache) return;
            
            try {
                // 创建缓存对象
                const cache = {
                    data: imageData,
                    url: imageUrl,
                    timestamp: Date.now()
                };
                
                // 估计缓存大小
                const cacheSize = JSON.stringify(cache).length;
                
                // 检查缓存大小是否超过限制
                if (cacheSize > this.maxCacheSize) {
                    console.warn(`壁纸缓存 ${cacheKey} 大小超过限制，不进行缓存`);
                    return;
                }
                
                // 存储缓存
                localStorage.setItem(cacheKey, JSON.stringify(cache));
                console.log(`壁纸已缓存到 ${cacheKey}，大小:`, (cacheSize / 1024).toFixed(2), 'KB');
            } catch (error) {
                console.warn(`缓存壁纸到 ${cacheKey} 失败:`, error);
                // 如果缓存失败（例如localStorage已满），清除缓存键
                try {
                    localStorage.removeItem(cacheKey);
                } catch (e) {
                    // 忽略清除失败的错误
                }
            }
        }
        
        // 从缓存加载壁纸
        async loadWallpaperFromCache(cacheKey) {
            try {
                const cache = this.checkWallpaperCache(cacheKey);
                if (!cache) return false;
                
                console.log(`正在从缓存 ${cacheKey} 加载壁纸...`);
                
                // 从Base64数据创建Blob对象
                const binary = atob(cache.data);
                const array = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    array[i] = binary.charCodeAt(i);
                }
                const blob = new Blob([array], { type: 'image/jpeg' });
                
                // 创建ObjectURL
                const objectUrl = URL.createObjectURL(blob);
                
                // 加载缓存的图片
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = objectUrl;
                });
                
                // 设置壁纸
                this.bingLayer.style.backgroundImage = `url('${objectUrl}')`;
                
                // 添加图片元素以确保显示
                this.bingLayer.innerHTML = '';
                const imgElement = document.createElement('img');
                imgElement.src = objectUrl;
                imgElement.style.cssText = 'position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover;';
                this.bingLayer.appendChild(imgElement);
                
                // 显示壁纸和效果层
                requestAnimationFrame(() => {
                    if (!this.keepAnimationOnly) {
                        this.bingLayer.style.opacity = '1';
                        this.bingLayer.style.transform = 'scale(1)';
                        this.effectLayer.style.opacity = '1';
                        
                        // 隐藏粒子动画层
                        this.hideParticlesBackground();
                    }
                });
                
                console.log(`从缓存 ${cacheKey} 加载壁纸成功`);
                return true;
            } catch (error) {
                console.warn(`从缓存 ${cacheKey} 加载壁纸失败:`, error);
                return false;
            }
        }
        
        // 预加载下一张壁纸并缓存
        async preloadNextWallpaper() {
            try {
                console.log('开始预加载下一张壁纸...');
                
                // 竞速加载多个API获取下一张壁纸
                const { url, loadTime, originalUrl, apiUrl } = await this.raceWallpaperApis();
                
                // 使用重定向后的实际URL
                const actualUrl = url || originalUrl;
                console.log(`下一张壁纸预加载成功，来源: ${apiUrl}，耗时: ${loadTime}ms`);
                
                // 获取图片的Base64数据并缓存到next_wallpaper键
                const imageData = await this.getImageAsBase64(actualUrl);
                this.cacheWallpaper(imageData, apiUrl, this.nextCacheKey);
                
                console.log('下一张壁纸已成功缓存');
            } catch (error) {
                console.error('预加载下一张壁纸失败:', error);
            }
        }

        // 获取并缓存图片的Base64数据
        async getImageAsBase64(url) {
            try {
                // 使用fetch获取图片
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP错误! 状态: ${response.status}`);
            
                // 获取blob数据
                const blob = await response.blob();
                
                // 转换为Base64
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        // 从DataURL中提取Base64字符串
                        const base64String = reader.result.split(',')[1];
                        resolve(base64String);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('获取图片Base64数据失败:', error);
                throw error;
            }
        }

        // 加载并显示必应壁纸
        async loadBingWallpaper() {
            try {
                // 将上次缓存的"下一张壁纸"作为当前壁纸
                const nextCache = this.checkWallpaperCache(this.nextCacheKey);
                if (nextCache) {
                    // 将"下一张"壁纸移动到"当前"壁纸缓存
                    localStorage.setItem(this.currentCacheKey, localStorage.getItem(this.nextCacheKey));
                    // 清除"下一张"壁纸缓存
                    localStorage.removeItem(this.nextCacheKey);
                }
                
                // 尝试从当前壁纸缓存加载
                if (await this.loadWallpaperFromCache(this.currentCacheKey)) {
                    // 成功从缓存加载，开始异步预加载下一张壁纸
                    setTimeout(() => this.preloadNextWallpaper(), 1000);
                    return true;
                }
                
                // 设置超时计时器，如果加载时间过长则显示粒子动画
                this.wallpaperLoadTimeout = setTimeout(() => {
                    this.activateParticlesBackground();
                }, this.loadTimeThreshold);
                
                console.log('无可用缓存，开始并行加载多个壁纸API');
                
                // 竞速加载多个API
                const { url, loadTime, originalUrl, apiUrl } = await this.raceWallpaperApis();
                
                // 清除超时计时器
                if (this.wallpaperLoadTimeout) {
                    clearTimeout(this.wallpaperLoadTimeout);
                    this.wallpaperLoadTimeout = null;
                }
                
                // 如果已经切换到动画模式，则不设置壁纸
                if (this.keepAnimationOnly) {
                    console.log('在加载过程中已切换到粒子动画模式，不设置壁纸');
                    return;
                }
                
                // 使用重定向后的实际URL
                const actualUrl = url || originalUrl;
                console.log(`壁纸加载成功，来源: ${apiUrl}，耗时: ${loadTime}ms`);
                
                // 预加载图片
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = actualUrl;
                });
                
                // 设置必应壁纸
                this.bingLayer.style.backgroundImage = `url('${actualUrl}')`;
                
                // 添加图片元素以确保显示
                this.bingLayer.innerHTML = '';
                const imgElement = document.createElement('img');
                imgElement.src = actualUrl;
                imgElement.style.cssText = 'position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover;';
                this.bingLayer.appendChild(imgElement);
                
                // 显示壁纸和效果层
                requestAnimationFrame(() => {
                    if (!this.keepAnimationOnly) {
                        this.bingLayer.style.opacity = '1';
                        this.bingLayer.style.transform = 'scale(1)'; // 缩放动画
                        this.effectLayer.style.opacity = '1';
                        
                        // 隐藏粒子动画层
                        this.hideParticlesBackground();
                    }
                });
                
                // 缓存壁纸
                try {
                    // 获取图片的Base64数据并缓存到当前壁纸缓存
                    const imageData = await this.getImageAsBase64(actualUrl);
                    this.cacheWallpaper(imageData, apiUrl, this.currentCacheKey);
                    
                    // 异步预加载下一张壁纸
                    setTimeout(() => this.preloadNextWallpaper(), 1000);
                } catch (cacheError) {
                    console.warn('缓存壁纸过程中出错:', cacheError);
                    // 缓存错误不影响壁纸显示
                }
                
                return true;
            } catch (error) {
                console.error('壁纸加载失败，启用粒子动画背景:', error);
                this.activateParticlesBackground();
                return false;
            }
        }
        
        // 主方法：设置壁纸
        async setWallpaper() {
            try {
                // 重置状态
                this.keepAnimationOnly = false;
                
                // 初始化容器
                this.initContainer();
                
                // 确保壁纸层初始是空的
                this.bingLayer.innerHTML = '';
                this.bingLayer.style.backgroundImage = 'none';
                this.bingLayer.style.opacity = '0';
                
                console.log('[WallpaperManager] 已重置壁纸层');
                
                // 加载并显示壁纸
                await this.loadBingWallpaper();
                
            } catch (error) {
                console.error('设置壁纸失败，启用粒子动画背景:', error);
                this.activateParticlesBackground();
            }
        }
    }

    // 导入 SearchAPI 类
    import SearchAPI from './search.js';

    // 重新添加 updateTime 函数
    function updateTime() {
        // 获取设置管理器实例
        const settingsManager = window.settingsManager;
        
        // 获取当前时间
        const now = new Date();
        
        // 根据时区设置调整时间
        let adjustedTime = now;
        
        if (settingsManager && settingsManager.settings.timezone !== 'auto') {
            // 获取本地时区偏移（分钟）
            const localOffset = now.getTimezoneOffset();
            
            // 计算目标时区与UTC的偏移（分钟）
            const targetOffset = -settingsManager.settings.timezoneOffset * 60;
            
            // 计算时差（毫秒）
            const offsetDiff = (localOffset + targetOffset) * 60 * 1000;
            
            // 调整时间
            adjustedTime = new Date(now.getTime() + offsetDiff);
        }
        
        // 更新时间显示
        const hours = String(adjustedTime.getHours()).padStart(2, '0');
        const minutes = String(adjustedTime.getMinutes()).padStart(2, '0');
        document.querySelector('.time').textContent = `${hours}:${minutes}`;
        
        // 更新日期显示
        const year = adjustedTime.getFullYear();
        const month = String(adjustedTime.getMonth() + 1).padStart(2, '0');
        const day = String(adjustedTime.getDate()).padStart(2, '0');
        const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
        const weekday = weekdays[adjustedTime.getDay()];
        document.querySelector('.date').textContent = `${year}年${month}月${day}日 ${weekday}`;
    }

    // 添加打字机效果函数
    function typeWriter(element, text, speed = 50) {
        let i = 0;
        element.textContent = '';
        const timer = setInterval(() => {
            if (i < text.length) {
                element.textContent += text.charAt(i);
                i++;
            } else {
                clearInterval(timer);
            }
        }, speed);
    }

    // 显示搜索结果
    function showResults(results) {
        const resultsContainer = document.querySelector('.results-container');
        const resultsDiv = document.querySelector('.results');
        const statsDiv = document.querySelector('.results-stats');
        const resultsSearchInput = document.querySelector('.results-search-input');
        
        resultsSearchInput.value = document.querySelector('.search-input').value;
        statsDiv.textContent = `找到约 ${results.data.length} 条结果`;
        
        resultsDiv.innerHTML = results.data.map(item => `
            <div class="result-card">
                <div class="result-title" onclick="window.open('${item.href}', '_blank')">${item.title}</div>
                <div class="result-url">${formatUrl(item.href)}</div>
                <div class="result-snippet">${item.abstract}</div>
                ${item.time ? `
                    <div class="result-meta">
                        <span class="result-time">${formatTime(item.time)}</span>
                    </div>
                ` : ''}
            </div>
        `).join('');

        resultsContainer.style.display = 'block';
        setTimeout(() => resultsContainer.style.opacity = '1', 10);
    }

    // 格式化URL显示
    function formatUrl(url) {
        try {
            const urlObj = new URL(url);
            return urlObj.hostname + urlObj.pathname.slice(0, 50) + (urlObj.pathname.length > 50 ? '...' : '');
        } catch {
            return url;
        }
    }

    // 格式化时间显示
    function formatTime(time) {
        const date = new Date(time);
        const now = new Date();
        const diff = now - date;
        
        // 如果时间差小于24小时，显示"x小时前"
        if (diff < 24 * 60 * 60 * 1000) {
            const hours = Math.floor(diff / (60 * 60 * 1000));
            return `${hours}小时前`;
        }
        
        // 否则显示具体日期
        return time.split(' ')[0];
    }

    // 更新日期显示
    function updateDate() {
        const now = new Date();
        const days = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
        const dateStr = `${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日 ${days[now.getDay()]}`;
        document.querySelector('.date').textContent = dateStr;
    }

    // 模拟获取天气数据
    async function getWeather() {
        try {
            // 这里可以替换为实际的天气API调用
            const weatherIcons = ['☀️', '⛅', '☁️', '🌧️', '⛈️', '❄️'];
            const weatherDescs = ['晴朗', '多云', '阴天', '小雨', '雷雨', '小雪'];
            const randomIndex = Math.floor(Math.random() * weatherIcons.length);
            const temp = Math.floor(Math.random() * 15) + 15; // 15-30度之间
            
            const weatherCard = document.querySelector('.weather-card');
            if (weatherCard) {
                weatherCard.querySelector('.weather-icon').textContent = weatherIcons[randomIndex];
                weatherCard.querySelector('.weather-temp').textContent = `${temp}°C`;
                weatherCard.querySelector('.weather-desc').textContent = weatherDescs[randomIndex];
                
                setTimeout(() => {
                    weatherCard.classList.add('visible');
                }, 1000);
            }
        } catch (error) {
            console.error('获取天气失败:', error);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const wallpaperManager = new WallpaperManager();
        wallpaperManager.setWallpaper();
        
        // 初始化设置系统
        const settingsManager = new SettingsManager();
        settingsManager.init();
        
        // 获取所有需要的DOM元素
        const searchContainer = document.querySelector('.search-container');
        const searchInput = document.querySelector('.search-input');
        const resultsSearchInput = document.querySelector('.results-search-input');
        const searchBtn = document.querySelector('.search-btn');
        const resultsContainer = document.querySelector('.results-container');
        const closeResults = document.querySelector('.close-results');
        const body = document.body;

        // 初始化
        updateTime();
        setInterval(updateTime, 1000);
        
        // 初始获取语录
        getQuote();
        
        // 添加全局变量跟踪定时器
        let quoteRefreshTimer = setInterval(getQuote, 30000); // 每30秒更新一次
        
        // 添加页面可见性变化监听
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // 页面可见时，如果定时器不存在则重新启动
                if (!quoteRefreshTimer) {
                    quoteRefreshTimer = setInterval(getQuote, 30000);
                }
                // 立即刷新一次语录
                getQuote();
            } else {
                // 页面不可见时，清除定时器
                clearInterval(quoteRefreshTimer);
                quoteRefreshTimer = null;
            }
        });

        // 清除搜索框内容并禁用自动填充
        if (searchInput) {
            searchInput.value = '';
            searchInput.setAttribute('autocomplete', 'off');
        }
        
        if (resultsSearchInput) {
            resultsSearchInput.value = '';
            resultsSearchInput.setAttribute('autocomplete', 'off');
        }

        // 添加页面重新获得焦点时的处理
        window.addEventListener('focus', () => {
            if (searchInput) searchInput.value = '';
            if (resultsSearchInput) resultsSearchInput.value = '';
        });

        // 搜索按钮点击事件
        searchBtn.addEventListener('click', () => {
            if (!searchContainer.classList.contains('active')) {
                searchContainer.classList.add('active');
                body.classList.add('search-active');
                setTimeout(() => searchInput.focus(), 300);
            } else if (searchInput.value.trim()) {
                performSearch(searchInput.value.trim());
            }
        });

        // 搜索框获得焦点事件
        searchInput.addEventListener('focus', () => {
            if (!searchContainer.classList.contains('active')) {
                searchContainer.classList.add('active');
                body.classList.add('search-active');
            }
        });

        // 点击其他区域关闭搜索框
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container') && searchContainer.classList.contains('active')) {
                searchContainer.classList.remove('active');
                body.classList.remove('search-active');
            }
            
            // 确保点击空白处也关闭搜索引擎下拉菜单
            if (!e.target.closest('.search-engine-selector')) {
                engineDropdown.classList.remove('show');
            }
        });

        // 阻止搜索框内的点击事件冒泡
        searchContainer.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // 修改回车键处理
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (!searchContainer.classList.contains('active')) {
                    searchContainer.classList.add('active');
                    body.classList.add('search-active');
                    setTimeout(() => searchInput.focus(), 300);
                } else if (searchInput.value.trim()) {
                    performSearch(searchInput.value.trim());
                }
            }
        });

        // 修改关闭结果页面时的处理
        closeResults.addEventListener('click', () => {
            const resultsContainer = document.querySelector('.results-container');
            const searchContainer = document.querySelector('.search-container');
            const initialContent = document.querySelector('.time, .quote-card');
            const searchInput = document.querySelector('.search-input');
            const resultsSearchInput = document.querySelector('.results-search-input');
            
            // 移除结果页可见性
            resultsContainer.classList.remove('visible');
            document.querySelector('.web-results-column').classList.remove('visible');
            document.querySelector('.ai-results-column').classList.remove('visible');
            
            // 恢复起始页内容
            searchContainer.style.transition = 'all 0.6s cubic-bezier(0.19, 1, 0.22, 1)';
            searchContainer.style.transform = 'translateY(0)';
            searchContainer.style.opacity = '1';
            initialContent.style.transition = 'opacity 0.6s ease';
            initialContent.style.opacity = '1';
            
            // 重置搜索框状态
            searchContainer.classList.remove('active');
            body.classList.remove('search-active');
            
            // 清除所有搜索框的内容
            searchInput.value = '';
            resultsSearchInput.value = '';
            
            // 等待动画完成后清理
            setTimeout(() => {
                resultsContainer.style.display = 'none';
                document.querySelector('.web-results').innerHTML = '';
                document.querySelector('.ai-messages').innerHTML = '';
            }, 600);
        });

        // 搜索引擎选择相关
        const engineSelector = document.querySelector('.search-engine-selector');
        const engineDropdown = document.querySelector('.search-engine-dropdown');
        const currentEngineIcon = document.getElementById('currentEngine');
        let currentEngine = 'bing'; // 默认搜索引擎

        // 读取保存的搜索引擎设置
        const savedEngine = localStorage.getItem('selectedEngine');
        if (savedEngine) {
            currentEngine = savedEngine;
            const option = document.querySelector(`.search-engine-option[data-engine="${savedEngine}"]`);
            if (option) {
                currentEngineIcon.src = option.getAttribute('data-icon');
                if (savedEngine === 'ai') {
                    searchInput.placeholder = '请输入';
                }
            }
        }

        // 处理搜索引擎选择器点击事件
        engineSelector.addEventListener('click', function(e) {
            e.stopPropagation(); // 阻止事件冒泡
            
            // 隐藏搜索联想框
            const suggestionsBox = document.querySelector('.search-suggestions');
            if (suggestionsBox) {
                suggestionsBox.style.display = 'none';
            }
            
            // 切换下拉菜单显示状态
            if (engineDropdown.style.display === 'block') {
                engineDropdown.style.display = 'none';
            } else {
                engineDropdown.style.display = 'block';
                // 添加动画效果
                engineDropdown.classList.add('animate-dropdown');
                setTimeout(() => engineDropdown.classList.remove('animate-dropdown'), 300);
            }
        });

        // 处理搜索引擎选项点击事件
        document.querySelectorAll('.search-engine-option').forEach(option => {
            option.addEventListener('click', function(e) {
                e.stopPropagation(); // 阻止事件冒泡
                
                // 获取所选搜索引擎信息
                const engine = this.getAttribute('data-engine');
                const icon = this.getAttribute('data-icon');
                
                // 更新当前搜索引擎变量 - 这是修复的关键
                currentEngine = engine;
                
                // 更新当前搜索引擎图标
                currentEngineIcon.src = icon;
                
                // 存储所选搜索引擎
                localStorage.setItem('selectedEngine', engine);
                
                // 隐藏下拉菜单
                engineDropdown.style.display = 'none';
                
                // 更新搜索框提示文本
                if (engine === 'ai') {
                    searchInput.placeholder = '请输入';
                } else {
                    searchInput.placeholder = '请搜索';
                }
                
                // 聚焦搜索框
                searchInput.focus();
            });
        });

        // 点击其他地方关闭下拉菜单
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-engine-selector')) {
                engineDropdown.style.display = 'none';
            }
        });

        // 快捷键支持
        document.addEventListener('keydown', (e) => {
            if (e.altKey) {
                const options = document.querySelectorAll('.search-engine-option');
                const index = parseInt(e.key) - 1;
                if (index >= 0 && index < options.length) {
                    const option = options[index];
                    currentEngine = option.dataset.engine;
                    currentEngineIcon.src = option.dataset.icon;
                    engineDropdown.classList.remove('show');
                    e.preventDefault();
                }
            }
            
            // 按下Esc键可清除搜索框内容
            if (e.key === 'Escape') {
                const searchInput = document.querySelector('.search-input');
                searchInput.value = '';
                searchInput.focus();
            }
            
            // 按下/键可以快速激活搜索
            if (e.key === '/' && !document.querySelector('.search-container').classList.contains('active')) {
                e.preventDefault();
                document.querySelector('.search-container').classList.add('active');
                body.classList.add('search-active');
                setTimeout(() => document.querySelector('.search-input').focus(), 300);
            }
        });

        // 修改搜索处理函数
        async function performSearch(query) {
            if (!query.trim()) return;

            switch (currentEngine) {
                case 'bing':
                    window.location.href = `https://cn.bing.com/search?q=${encodeURIComponent(query)}&form=QBLH`;
                    break;
                case 'baidu':
                    window.location.href = `https://www.baidu.com/s?wd=${encodeURIComponent(query)}`;
                    break;
                case 'google':
                    window.location.href = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
                    break;
                case 'ai':
                    // 使用原有的 AI 搜索逻辑
                    try {
                        const searchAPI = new SearchAPI();
                        const searchContainer = document.querySelector('.search-container');
                        const resultsContainer = document.querySelector('.results-container');
                        const initialContent = document.querySelector('.time, .quote-card');
                        
                        // 确保背景模糊效果
                        body.classList.add('search-active');
                        
                        // 1. 淡出起始页内容
                        initialContent.style.transition = 'opacity 0.3s ease';
                        initialContent.style.opacity = '0';
                        searchContainer.style.transition = 'all 0.6s cubic-bezier(0.19, 1, 0.22, 1)';
                        searchContainer.style.transform = 'translateY(-30px)';
                        searchContainer.style.opacity = '0';
                        
                        // 2. 显示结果页容器
                        resultsContainer.style.display = 'block';
                        
                        // 3. 开始结果页动画
                        requestAnimationFrame(() => {
                            resultsContainer.classList.add('visible');
                            
                            // 延迟显示搜索结果列
                            setTimeout(() => {
                                document.querySelector('.web-results-column').classList.add('visible');
                                document.querySelector('.ai-results-column').classList.add('visible');
                            }, 300);
                        });

                        // 4. 设置搜索框值
                        document.querySelector('.results-search-input').value = query;
                        
                        // 显示加载状态
                        const webResults = document.querySelector('.web-results');
                        const aiMessages = document.querySelector('.ai-messages');
                        
                        webResults.innerHTML = `
                            <div class="loading-container">
                                <div class="loading-circle"></div>
                                <p>搜索中...</p>
                            </div>
                        `;
                        
                        aiMessages.innerHTML = `
                            <div class="loading-container">
                                <div class="loading-circle"></div>
                                <p>AI 正在思考中...</p>
                            </div>
                        `;

                        // 调用搜索 API
                        searchAPI.getAIResponse(
                            query,
                            displayWebResults,
                            displayAIContent,
                            async (finalContent) => {
                                try {
                                    // 先显示加载状态
                                    displayMindMapLoading();
                                    
                                    // 等待 AI 回答完成
                                    await new Promise(resolve => {
                                        const checkComplete = () => {
                                            const messageDiv = document.querySelector('.ai-message');
                                            if (messageDiv?.dataset.complete === 'true') {
                                                resolve();
                                            } else {
                                                setTimeout(checkComplete, 100);
                                            }
                                        };
                                        checkComplete();
                                    });
                                    
                                    // 生成思维导图
                                    const mindMapUrl = await searchAPI.generateMindMap(finalContent);
                                    if (mindMapUrl) {
                                        displayMindMap(mindMapUrl);
                                    } else {
                                        const loadingMindMap = document.querySelector('.mind-map.loading');
                                        if (loadingMindMap) {
                                            clearInterval(Number(loadingMindMap.dataset.animationInterval));
                                            loadingMindMap.remove();
                                        }
                                    }
                                } catch (error) {
                                    console.error('思维导图生成失败:', error);
                                    const loadingMindMap = document.querySelector('.mind-map.loading');
                                    if (loadingMindMap) {
                                        clearInterval(Number(loadingMindMap.dataset.animationInterval));
                                        loadingMindMap.remove();
                                    }
                                }
                            }
                        );
                    } catch (error) {
                        console.error('搜索失败:', error);
                        displayError();
                    }
                    break;
            }
        }

        // 修改 displayAIContent 函数，添加完成标记
        function displayAIContent(content, images = null) {
            const aiMessages = document.querySelector('.ai-messages');
            
            // 如果内容为空，不更新显示
            if (!content.trim()) return;
            
            // 如果是第一次显示内容，清除加载状态
            if (aiMessages.querySelector('.loading-container')) {
                aiMessages.innerHTML = '<div class="ai-message markdown-body"></div>';
            }
            
            const messageDiv = aiMessages.querySelector('.ai-message');
            if (messageDiv) {
                const processedContent = content.replace(
                    /【(\d+)†source】/g, 
                    '<sup class="reference-mark" title="参考资料来源">[$1]</sup>'
                );
                
                messageDiv.innerHTML = marked.parse(processedContent);
                
                // 添加动画效果
                if (!messageDiv.classList.contains('visible')) {
                    requestAnimationFrame(() => {
                        messageDiv.classList.add('visible');
                        // 标记 AI 回答已完成显示
                        messageDiv.dataset.complete = 'true';
                    });
                }
            }
        }

        // 修改思维导图加载状态显示
        function displayMindMapLoading() {
            const aiMessages = document.querySelector('.ai-messages');
            const existingMindMap = aiMessages.querySelector('.mind-map');
            if (existingMindMap) {
                existingMindMap.remove();
            }

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'mind-map loading';
            loadingDiv.innerHTML = `
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">
                        <p class="loading-title">正在生成思维导图</p>
                        <p class="loading-dots">...</p>
                    </div>
                </div>
            `;
            aiMessages.appendChild(loadingDiv);

            // 添加加载动画
            const dots = loadingDiv.querySelector('.loading-dots');
            let count = 0;
            const dotAnimation = setInterval(() => {
                dots.textContent = '.'.repeat((count % 4) || 1);
                count++;
            }, 500);

            // 保存动画引用以便后续清除
            loadingDiv.dataset.animationInterval = dotAnimation;

            // 确保加载状态可见
            requestAnimationFrame(() => {
                loadingDiv.style.opacity = '1';
                loadingDiv.style.transform = 'translateY(0)';
            });
        }

        // 修改思维导图显示函数
        function displayMindMap(url) {
            const aiMessages = document.querySelector('.ai-messages');
            const messageDiv = aiMessages.querySelector('.ai-message');
            
            // 确保 AI 回答已完全显示
            if (!messageDiv || !messageDiv.dataset.complete) {
                setTimeout(() => displayMindMap(url), 100);
                return;
            }
            
            // 移除现有的加载状态
            const loadingMindMap = aiMessages.querySelector('.mind-map.loading');
            if (loadingMindMap) {
                // 清除加载动画
                clearInterval(Number(loadingMindMap.dataset.animationInterval));
                loadingMindMap.remove();
            }

            // 创建思维导图容器
            const mindMapDiv = document.createElement('div');
            mindMapDiv.className = 'mind-map';
            mindMapDiv.innerHTML = `
                <h3><i class="fas fa-project-diagram"></i> 思维导图</h3>
                <div class="mind-map-content">
                    <img src="${url}" alt="思维导图" class="mind-map-image">
                </div>
            `;
            aiMessages.appendChild(mindMapDiv);

            // 添加动画效果
            requestAnimationFrame(() => {
                setTimeout(() => {
                    mindMapDiv.classList.add('visible');
                }, 100);
            });
        }

        // 修改搜索结果显示函数
        function displayWebResults(results) {
            const webResults = document.querySelector('.web-results');
            
            // 清除现有结果
            webResults.innerHTML = '';
            
            if (!results || results.length === 0) {
                webResults.innerHTML = `
                    <div class="no-results">
                        <i class="fas fa-search"></i>
                        <p>未找到相关搜索结果</p>
                    </div>
                `;
                return;
            }
            
            // 遍历结果，确保每个结果都是顶层元素
            results.forEach((result, index) => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'search-result';
                resultDiv.dataset.index = index;
                
                resultDiv.innerHTML = `
                    <div class="result-content">
                        <h3>
                            <a href="${result.link}" target="_blank" rel="noopener noreferrer">
                                ${result.title}
                            </a>
                        </h3>
                        <div class="result-url">${formatUrl(result.link)}</div>
                        <p class="result-snippet">${result.content}</p>
                        <div class="result-meta">
                            ${result.time ? `<span class="result-time"><i class="far fa-clock"></i> ${formatTime(result.time)}</span>` : ''}
                            ${result.media ? `<span class="result-source"><i class="far fa-newspaper"></i> ${result.media}</span>` : ''}
                        </div>
                    </div>
                    <div class="icon-links">
                        <a href="https://cn.bing.com/search?q=${encodeURIComponent(result.title)}&form=QBLH" class="icon-link" target="_blank">
                            <img src="https://www.bing.com/favicon.ico" alt="Bing" class="icon">
                        </a>
                    </div>
                `;
                
                webResults.appendChild(resultDiv);
            });

            // 添加动画效果
            requestAnimationFrame(() => {
                webResults.querySelectorAll('.search-result').forEach((result, index) => {
                    setTimeout(() => {
                        result.classList.add('visible');
                    }, index * 150);
                });
            });
        }

        // 添加错误显示函数
        function displayError() {
            const webResults = document.querySelector('.web-results');
            const aiMessages = document.querySelector('.ai-messages');
            
            webResults.innerHTML = `
                <div class="error-message">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>搜索结果获取失败，请稍后重试</p>
                </div>
            `;
            
            aiMessages.innerHTML = `
                <div class="ai-message error">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>AI 响应获取失败，请稍后重试</p>
                </div>
            `;
        }

        // 添加结果页面的搜索功能
        const resultsSearchBtn = document.querySelector('.results-search-btn');

        resultsSearchBtn.addEventListener('click', () => {
            const query = resultsSearchInput.value.trim();
            if (query) {
                performSearch(query);
            }
        });

        resultsSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = resultsSearchInput.value.trim();
                if (query) {
                    // 添加加载状态
                    const searchBtn = document.querySelector('.results-search-btn');
                    searchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    searchBtn.disabled = true;

                    // 执行搜索
                    performSearch(query);

                    // 搜索完成后恢复状态
                    setTimeout(() => {
                        searchBtn.innerHTML = '<i class="fas fa-search"></i>';
                        searchBtn.disabled = false;
                    }, 1000);
                }
            }
        });

        // 更新日期和天气
        updateDate();
        getWeather();
        
        // 显示快速链接
        setTimeout(() => {
            const quickLinks = document.querySelector('.quick-links');
            if (quickLinks) {
                quickLinks.classList.add('visible');
            }
        }, 1500);

        // 标记搜索容器为已加载状态，以触发搜索按钮的脉冲动画
        setTimeout(() => {
            const searchContainer = document.querySelector('.search-container');
            if (searchContainer) {
                searchContainer.classList.add('loaded');
            }
        }, 2000);

        // 修复在设置sug函数前window.bing未定义的错误
        if(!window.bing) window.bing = {};

        // 修改JSONP回调函数，使用SVG图标
        window.bing.sug = function(data) {
            const suggestionsBox = document.querySelector('.search-suggestions');
            if(!suggestionsBox) return;
            
            if(data && data.AS && data.AS.Results && data.AS.Results[0] && data.AS.Results[0].Suggests) {
                const suggests = data.AS.Results[0].Suggests;
                if(suggests.length > 0) {
                    // 只显示前3个搜索建议
                    const limitedSuggests = suggests.slice(0, 3);
                    
                    // 定义搜索SVG图标
                    const searchSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="currentColor" class="suggestion-icon">
                        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                    </svg>`;
                    
                    suggestionsBox.innerHTML = limitedSuggests.map((item, index) => {
                        // 限制文本长度为15个字符
                        const limitedText = item.Txt.length > 15 ? 
                            item.Txt.substring(0, 14) + '...' : 
                            item.Txt;
                        
                        return `
                            <div class="search-suggestion-item" data-index="${index}" data-query="${item.Txt}">
                                ${searchSvg}
                                <span>${limitedText}</span>
                            </div>
                        `;
                    }).join('');
                    
                    // 使用更平滑的显示方式
                    suggestionsBox.style.display = 'none';
                    setTimeout(() => {
                        suggestionsBox.style.display = 'flex';
                        // 添加动画类
                        suggestionsBox.classList.add('animate-in');
                        setTimeout(() => suggestionsBox.classList.remove('animate-in'), 300);
                    }, 10);
                    
                    // 添加点击事件
                    document.querySelectorAll('.search-suggestion-item').forEach(item => {
                        item.addEventListener('click', function() {
                            const query = this.getAttribute('data-query');
                            document.querySelector('.search-input').value = query;
                            localStorage.setItem('searchCompleted', 'true');
                            performSearch(query);
                            suggestionsBox.style.display = 'none';
                        });
                    });
                } else {
                    suggestionsBox.style.display = 'none';
                }
            } else {
                suggestionsBox.style.display = 'none';
            }
        };

        // 添加防抖函数
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // 修改搜索记忆功能部分
        function setupSearchSuggestions() {
            const searchInput = document.querySelector('.search-input');
            const searchContainer = document.querySelector('.search-container');
            
            // 创建搜索建议容器
            if(!document.querySelector('.search-suggestions')) {
                const suggestionsBox = document.createElement('div');
                suggestionsBox.className = 'search-suggestions';
                searchContainer.appendChild(suggestionsBox);
            }
            
            // 只在未完成搜索时恢复上次内容
            const searchCompleted = localStorage.getItem('searchCompleted') === 'true';
            const savedQuery = localStorage.getItem('lastSearchQuery');
            
            // 如果未完成搜索且有保存的内容，才恢复输入
            if (savedQuery && !searchCompleted) {
                searchInput.value = savedQuery;
            } else {
                // 清除之前保存的内容
                localStorage.removeItem('lastSearchQuery');
                localStorage.removeItem('searchCompleted');
            }
            
            // 监听输入事件并保存输入内容
            searchInput.addEventListener('input', function() {
                // 保存当前输入内容，并标记为未完成搜索
                localStorage.setItem('lastSearchQuery', this.value);
                localStorage.setItem('searchCompleted', 'false');
                
                // 处理搜索联想...
                const query = this.value.trim();
                if (query.length < 1) {
                    document.querySelector('.search-suggestions').style.display = 'none';
                    return;
                }
                
                // 触发搜索联想
                fetchSuggestions(query);
            });
            
            // 抽离JSONP请求逻辑为独立函数
            const fetchSuggestions = debounce(function(query) {
                // 创建JSONP请求
                const script = document.createElement('script');
                script.src = `https://api.bing.com/qsonhs.aspx?type=cb&q=${encodeURIComponent(query)}&cb=window.bing.sug`;
                document.body.appendChild(script);
                
                // 清理JSONP脚本标签
                script.onload = function() {
                    document.body.removeChild(script);
                };
            }, 400);
            
            // 修改搜索按钮点击事件，标记搜索已完成
            document.querySelector('.search-btn').addEventListener('click', function() {
                localStorage.setItem('searchCompleted', 'true');
            });
            
            // 同样修改键盘Enter键搜索事件
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    localStorage.setItem('searchCompleted', 'true');
                    // 原有搜索代码...
                }
            });
            
            // 同样修改搜索联想项点击事件
            document.querySelectorAll('.search-suggestion-item').forEach(item => {
                item.addEventListener('click', function() {
                    const query = this.getAttribute('data-query');
                    document.querySelector('.search-input').value = query;
                    localStorage.setItem('searchCompleted', 'true');
                    performSearch(query);
                    suggestionsBox.style.display = 'none';
                });
            });

            // 监听搜索框状态变化
            document.addEventListener('click', function(e) {
                // 获取搜索容器和建议框
                const searchContainer = document.querySelector('.search-container');
                const suggestionsBox = document.querySelector('.search-suggestions');
                
                // 如果点击的不是搜索容器内的元素，且搜索容器不再处于激活状态
                if (!e.target.closest('.search-container') || !searchContainer.classList.contains('active')) {
                    // 隐藏搜索联想
                    if (suggestionsBox) {
                        suggestionsBox.style.display = 'none';
                    }
                }
            });
        }

        // 添加搜索联想初始化
        setupSearchSuggestions();
    });
    </script>
</body>
</html>